<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Disaster Analytics Dashboard</title>
    <!-- Load Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
     integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
     crossorigin=""/>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
     integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
     crossorigin=""></script>
    <!-- Load Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Load dayjs and necessary plugins -->
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1/dayjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1/plugin/utc.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1/plugin/customParseFormat.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1/plugin/quarterOfYear.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        #map-container {
            position: relative;
            margin-bottom: 3rem; /* mb-12 */
        }
        .map-container-small {
            height: 350px;
        }
        .map-container-large {
            height: 75vh;
        }
        #map {
            width: 100%;
            height: 100%;
            border-radius: 0.5rem;
            border: 1px solid #d1d5db;
            z-index: 1;
            transition: height 0.3s ease-in-out;
        }
        .chart-container {
            position: relative;
            margin: auto;
            height: 50vh;
            width: 90%;
        }
        .small-chart-container {
             position: relative;
             margin: auto;
             height: 45vh;
             width: 95%;
             max-width: 500px;
        }
        input[type="date"], select {
            padding: 0.5rem;
            border: 1px solid #d1d5db; /* gray-300 */
            border-radius: 0.375rem; /* rounded-md */
            background-color: white;
            cursor: pointer;
        }
        .na-value {
            color: #9ca3af; /* gray-400 */
            font-style: italic;
        }
        input:disabled, select:disabled {
            background-color: #f3f4f6; /* gray-100 */
            cursor: not-allowed;
            opacity: 0.7;
        }
        .info.legend {
            background: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
            line-height: 1.4;
            font-size: 12px;
        }
        .info.legend i {
            width: 18px;
            height: 18px;
            float: left;
            margin-right: 8px;
            opacity: 0.7;
            border: 1px solid #999;
        }
        /* Style for the main metric selector */
        #metricSelector {
            font-weight: 600;
            font-size: 1.125rem; /* text-lg */
            padding: 0.5rem 1rem;
            border-color: #a5b4fc; /* indigo-300 */
            background-color: #eef2ff; /* indigo-50 */
        }
    </style>
</head>
<body class="bg-gray-100 p-4 md:p-8">

    <div class="mx-auto bg-white rounded-lg shadow-md p-6">
        <div class="flex justify-between items-center mb-6">
            <h1 class="text-2xl font-bold text-gray-800">Disaster Impact Dashboard</h1>
            <a href="https://27.110.161.135" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-md shadow-sm transition duration-150 ease-in-out">
                &larr; Return to Home
            </a>
        </div>

        <!-- Filter Section -->
        <!-- <<< MODIFIED: Grid layout to fit new filters >>> -->
        <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-5 gap-4 mb-6 p-4 border border-gray-200 rounded-lg bg-gray-50 items-end">
             <div>
                <label for="provinceFilter" class="block text-sm font-medium text-gray-700 mb-1">Province</label>
                <select id="provinceFilter" name="province" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md shadow-sm">
                    <option value="">All Provinces</option>
                </select>
            </div>
            <div>
                <label for="municipalityFilter" class="block text-sm font-medium text-gray-700 mb-1">Municipality</label>
                <select id="municipalityFilter" name="municipality" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md shadow-sm bg-gray-200" disabled>
                    <option value="">All (Select Province First)</option>
                </select>
            </div>
            <div>
                <label for="categoryFilter" class="block text-sm font-medium text-gray-700 mb-1">Disaster Category</label>
                <select id="categoryFilter" name="category" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md shadow-sm">
                    <option value="">All Categories</option>
                </select>
            </div>
            <!-- <<< ADDED: Commodity Filter >>> -->
            <div>
                <label for="commodityFilter" class="block text-sm font-medium text-gray-700 mb-1">Commodity</label>
                <select id="commodityFilter" name="commodity" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md shadow-sm">
                    <option value="">All Commodities</option>
                </select>
            </div>
             <div>
                <label for="yearFilter" class="block text-sm font-medium text-gray-700 mb-1">Year</label>
                <select id="yearFilter" name="year" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md shadow-sm">
                    <option value="">All Years</option>
                </select>
            </div>
            <div>
                <label for="quarterFilter" class="block text-sm font-medium text-gray-700 mb-1">Quarter</label>
                <select id="quarterFilter" name="quarter" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md shadow-sm">
                    <option value="">All Quarters</option>
                    <option value="1">Q1 (Jan-Mar)</option>
                    <option value="2">Q2 (Apr-Jun)</option>
                    <option value="3">Q3 (Jul-Sep)</option>
                    <option value="4">Q4 (Oct-Dec)</option>
                </select>
            </div>
             <div>
                <label for="startDateFilter" class="block text-sm font-medium text-gray-700 mb-1">Start Date</label>
                <input type="date" id="startDateFilter" name="start_date" class="mt-1 block w-full text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md shadow-sm">
            </div>
             <div>
                <label for="endDateFilter" class="block text-sm font-medium text-gray-700 mb-1">End Date</label>
                <input type="date" id="endDateFilter" name="end_date" class="mt-1 block w-full text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md shadow-sm">
            </div>
            <!-- <<< ADDED: Metric Selector >>> -->
            <div class="lg:col-span-1">
                <label for="metricSelector" class="block text-sm font-medium text-gray-700 mb-1">Analysis Metric</label>
                <select id="metricSelector" name="metric" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md shadow-sm">
                    <option value="total_losses_php" selected>Total Losses (PHP)</option>
                    <option value="total_farmers_affected">Farmers Affected</option>
                    <option value="area_total_affected_ha">Area Affected (ha)</option>
                    <option value="area_partially_damaged_ha">Area Partially Damaged (ha)</option>
                    <option value="area_totally_damaged_ha">Area Totally Damaged (ha)</option>
                    <option value="losses_php_production_cost">Production Cost Losses (PHP)</option>
                    <option value="losses_php_farm_gate">Farm Gate Losses (PHP)</option>
                </select>
            </div>
            <div>
                <button id="applyFiltersBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md shadow-sm transition duration-150 ease-in-out">
                    Apply Filters
                </button>
            </div>
        </div>

        <!-- Loading / Error Messages -->
        <div id="loading" class="text-center text-gray-500 my-4">Loading data...</div>
        <div id="error" class="text-center text-red-500 my-4 hidden"></div>
        <div id="noData" class="text-center text-gray-500 my-4 hidden">No data available for the selected filters.</div>

        <!-- Leaflet Map Container -->
        <div class="flex justify-between items-center mb-4">
            <h2 class="text-xl font-semibold text-gray-700">Map Analysis: <span id="mapTitleMetric">Total Losses (PHP)</span></h2>
            <button id="toggleMapBtn" title="Toggle Map Size" class="p-2 rounded-md hover:bg-gray-100 text-gray-600">
                <svg id="mapExpandIcon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9 9M3.75 20.25v-4.5m0 4.5h4.5m-4.5 0L9 15M20.25 3.75v4.5m0-4.5h-4.5m4.5 0L15 9m5.25 11.25v-4.5m0 4.5h-4.5m4.5 0L15 15" />
                </svg>
                <svg id="mapMinimizeIcon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6 hidden">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M9 9V4.5M9 9H4.5M9 9L3.75 3.75M9 15v4.5M9 15H4.5M9 15l-5.25 5.25M15 9V4.5M15 9h4.5M15 9l5.25-5.25M15 15v4.5M15 15h4.5M15 15l5.25 5.25" />
                </svg>
            </button>
        </div>
        <div id="map-container" class="map-container-small">
            <div id="map"></div>
        </div>


        <!-- Main Bar Chart Canvas -->
        <div class="chart-container mb-12">
            <canvas id="lossesChart"></canvas>
        </div>

        <!-- Row for Additional Charts -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-8 mb-12">
            <!-- Line Chart Container -->
            <div class="small-chart-container bg-gray-50 p-4 pb-6 rounded-lg shadow-sm border border-gray-200">
                 <h2 class="text-lg font-semibold text-center text-gray-700 mb-3"><span id="timeSeriesTitleMetric">Losses</span> Over Time (Monthly)</h2>
                <canvas id="timeSeriesChart"></canvas>
            </div>
             <!-- Pie Chart Container -->
            <div class="small-chart-container bg-gray-50 p-4 pb-6 rounded-lg shadow-sm border border-gray-200">
                 <h2 class="text-lg font-semibold text-center text-gray-700 mb-3"><span id="pieTitleMetric">Loss</span> Distribution by Category</h2>
                <canvas id="categoryPieChart"></canvas>
            </div>
        </div>


        <!-- Data Table -->
        <div class="flex justify-between items-center mb-4">
            <h2 class="text-xl font-semibold text-gray-700">Detailed Records (Max 100 shown)</h2>
            <div>
                <label for="tableSearch" class="sr-only">Search Table</label>
                <input type="text" id="tableSearch" placeholder="Search table..." class="block w-full pl-3 pr-4 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md shadow-sm">
            </div>
        </div>

        <div class="overflow-x-auto shadow rounded-lg">
            <table id="dataTable" class="min-w-full bg-white border border-gray-200 hidden">
                <thead class="bg-gray-100">
                    <tr>
                        <th class="px-4 py-3 border-b border-gray-200 text-left text-xs font-semibold text-gray-600 uppercase tracking-wider">Date Start</th>
                        <th class="px-4 py-3 border-b border-gray-200 text-left text-xs font-semibold text-gray-600 uppercase tracking-wider">Province</th>
                        <th class="px-4 py-3 border-b border-gray-200 text-left text-xs font-semibold text-gray-600 uppercase tracking-wider">Municipality</th>
                        <th class="px-4 py-3 border-b border-gray-200 text-left text-xs font-semibold text-gray-600 uppercase tracking-wider">Commodity</th>
                        <th class="px-4 py-3 border-b border-gray-200 text-left text-xs font-semibold text-gray-600 uppercase tracking-wider">Disaster Category</th>
                        <!-- <<< MODIFIED: Expanded table headers >>> -->
                        <th class="px-4 py-3 border-b border-gray-200 text-right text-xs font-semibold text-gray-600 uppercase tracking-wider">Farmers Affected</th>
                        <th class="px-4 py-3 border-b border-gray-200 text-right text-xs font-semibold text-gray-600 uppercase tracking-wider">Area Affected (ha)</th>
                        <th class="px-4 py-3 border-b border-gray-200 text-right text-xs font-semibold text-gray-600 uppercase tracking-wider">Area Partially Damaged (ha)</th>
                        <th class="px-4 py-3 border-b border-gray-200 text-right text-xs font-semibold text-gray-600 uppercase tracking-wider">Area Totally Damaged (ha)</th>
                        <th class="px-4 py-3 border-b border-gray-200 text-right text-xs font-semibold text-gray-600 uppercase tracking-wider">Losses - Prod. Cost (PHP)</th>
                        <th class="px-4 py-3 border-b border-gray-200 text-right text-xs font-semibold text-gray-600 uppercase tracking-wider">Losses - Farm Gate (PHP)</th>
                        <th class="px-4 py-3 border-b border-gray-200 text-right text-xs font-semibold text-gray-600 uppercase tracking-wider">Losses - Grand Total (PHP)</th>
                        <th class="px-4 py-3 border-b border-gray-200 text-right text-xs font-semibold text-gray-600 uppercase tracking-wider">Registered Farmers</th>
                        <th class="px-4 py-3 border-b border-gray-200 text-right text-xs font-semibold text-gray-600 uppercase tracking-wider">Declared Rice Area (ha)</th>
                        <th class="px-4 py-3 border-b border-gray-200 text-right text-xs font-semibold text-gray-600 uppercase tracking-wider">Affected Farmers (%)</th>
                    </tr>
                </thead>
                <tbody id="dataTableBody" class="divide-y divide-gray-200">
                    <!-- Data rows will be inserted here -->
                </tbody>
            </table>
             <div id="tableNote" class="text-xs text-gray-500 mt-2 px-1 hidden">* Farmer registry data (where available) is joined for calculation.</div>
        </div>

    </div>

    <script>
        // --- Enable Dayjs plugins ---
        dayjs.extend(dayjs_plugin_utc);
        dayjs.extend(dayjs_plugin_customParseFormat);
        dayjs.extend(dayjs_plugin_quarterOfYear);

        // --- Constants and Globals ---
        const chartApiUrl = 'http://localhost:8000/api/raw';
        const mapApiUrl = 'http://localhost:8000/query';

        const loadingDiv = document.getElementById('loading');
        const errorDiv = document.getElementById('error');
        const noDataDiv = document.getElementById('noData');
        const dataTable = document.getElementById('dataTable');
        const dataTableBody = document.getElementById('dataTableBody');
        const tableNote = document.getElementById('tableNote');

        // Chart elements and variables
        const barChartCanvas = document.getElementById('lossesChart');
        const timeSeriesCanvas = document.getElementById('timeSeriesChart');
        const categoryPieCanvas = document.getElementById('categoryPieChart');
        let barChartInstance = null;
        let timeSeriesChartInstance = null;
        let categoryPieChartInstance = null;
        let provinceMunicipalityMap = {};
        let commodityMap = {}; // <<< ADDED: For commodities

        // Map variables
        const mapContainer = document.getElementById('map-container');
        let mapInstance = null;
        let geojsonLayer = null;
        let mapLegend = null;
        const mapTitleMetric = document.getElementById('mapTitleMetric'); // <<< ADDED
        const timeSeriesTitleMetric = document.getElementById('timeSeriesTitleMetric'); // <<< ADDED
        const pieTitleMetric = document.getElementById('pieTitleMetric'); // <<< ADDED

        // Filter elements
        const provinceFilter = document.getElementById('provinceFilter');
        const categoryFilter = document.getElementById('categoryFilter');
        const municipalityFilter = document.getElementById('municipalityFilter');
        const commodityFilter = document.getElementById('commodityFilter'); // <<< ADDED
        const quarterFilter = document.getElementById('quarterFilter');
        const yearFilter = document.getElementById('yearFilter');
        const startDateFilter = document.getElementById('startDateFilter');
        const endDateFilter = document.getElementById('endDateFilter');
        const metricSelector = document.getElementById('metricSelector'); // <<< ADDED
        const applyFiltersBtn = document.getElementById('applyFiltersBtn');
        const tableSearchInput = document.getElementById('tableSearch');
        const toggleMapBtn = document.getElementById('toggleMapBtn');
        const mapExpandIcon = document.getElementById('mapExpandIcon');
        const mapMinimizeIcon = document.getElementById('mapMinimizeIcon');

        // --- Helper: Format Numbers ---
        function formatNumber(value) {
            value = parseFloat(value);
            if (isNaN(value)) return '0';
            if (value >= 1e9) return (value / 1e9).toFixed(1) + ' B';
            if (value >= 1e6) return (value / 1e6).toFixed(1) + ' M';
            if (value >= 1e3) return (value / 1e3).toFixed(1) + ' K';
            return value.toLocaleString();
        }
        function formatCurrency(value) {
            const numericValue = parseFloat(value);
            return (isNaN(numericValue) ? 0 : numericValue).toLocaleString('en-US', { style: 'currency', currency: 'PHP' });
        }
        function formatInt(value) {
            const intValue = parseInt(value, 10);
            return (isNaN(intValue) ? 0 : intValue).toLocaleString();
        }
        function formatPercentage(value) {
            const numericValue = parseFloat(value);
             if (value === null || value === undefined || isNaN(numericValue)) {
                 return '<span class="na-value">N/A</span>';
             }
             return numericValue.toFixed(2) + '%';
        }
        function formatRegistryNumber(value) {
             const numericValue = parseFloat(value);
             if (value === null || value === undefined || isNaN(numericValue) || numericValue === 0) {
                 return '<span class="na-value">N/A</span>';
             }
             return value === parseInt(value, 10) ? formatInt(value) : parseFloat(value).toFixed(2).toLocaleString();
        }
        function formatText(value) {
             if (value === null || value === undefined || value === 'N/A' || value === 'Unknown' || value === '') {
                 return '<span class="na-value">N/A</span>';
             }
             return value;
        }

        // --- Map Helper Functions ---
        // <<< MODIFIED: Color and Popup functions now dynamic based on selected metric >>>
        function getMapColor(value) {
            value = parseFloat(value) || 0;
            const selectedMetric = metricSelector.value;
            
            // Dynamic thresholds based on metric
            let thresholds = [0, 100000, 1000000, 5000000, 10000000, 20000000, 50000000, 100000000]; // Default for money
            if (selectedMetric.includes('farmers')) {
                thresholds = [0, 100, 500, 1000, 2500, 5000, 10000, 20000]; // For counts
            } else if (selectedMetric.includes('area')) {
                 thresholds = [0, 100, 500, 1000, 2500, 5000, 10000, 20000]; // For area
            }

            // Colors remain the same
            const colors = ['#FFEDA0', '#FED976', '#FEB24C', '#FD8D3C', '#FC4E2A', '#E31A1C', '#BD0026', '#800026'];
            
            for (let i = thresholds.length - 1; i >= 0; i--) {
                if (value > thresholds[i]) {
                    return colors[i];
                }
            }
            return '#FFEDA0'; // Default for 0 or lowest
        }

        function styleMapFeature(feature) {
            const selectedMetric = metricSelector.value;
            return {
                fillColor: getMapColor(feature.properties[selectedMetric]), // Use selected metric
                weight: 1,
                opacity: 1,
                color: '#666',
                fillOpacity: 0.7
            };
        }

        function onEachMapFeature(feature, layer) {
            if (feature.properties) {
                const props = feature.properties;
                const selectedMetric = metricSelector.value;
                const selectedMetricText = metricSelector.options[metricSelector.selectedIndex].text;
                
                // Dynamic formatter for the popup
                let metricValue;
                if (selectedMetric.includes('losses')) {
                    metricValue = formatCurrency(props[selectedMetric]);
                } else if (selectedMetric.includes('farmers')) {
                    metricValue = formatInt(props[selectedMetric]);
                } else if (selectedMetric.includes('area')) {
                    metricValue = formatRegistryNumber(props[selectedMetric]) + ' ha';
                } else {
                    metricValue = formatInt(props[selectedMetric]);
                }

                let commoditiesHtml = '<span class="na-value">N/A</span>';
                if (props.commodities_affected && props.commodities_affected.length > 0) {
                    commoditiesHtml = props.commodities_affected.join(', ');
                }

                const content = `
                    <div class="font-sans">
                        <div class="font-bold text-base mb-1">${props.municipality_name || 'N/A'}</div>
                        <div class="text-sm">
                            <strong>Province:</strong> ${props.province_name || 'N/A'}<br>
                            <strong>${selectedMetricText}:</strong> ${metricValue}<br>
                            <hr class="my-1">
                            <strong>Commodities Affected:</strong> ${commoditiesHtml}<br> 
                            <strong>Total Losses:</strong> ${formatCurrency(props.total_losses_php)}<br>
                            <strong>Farmers Affected:</strong> ${formatInt(props.total_farmers_affected)}<br>
                            <strong>Area Affected:</strong> ${formatRegistryNumber(props.area_total_affected_ha)} ha
                        </div>
                    </div>
                `;
                layer.bindPopup(content);
                layer.on({
                    mouseover: (e) => e.target.setStyle({ weight: 3, color: '#333' }),
                    mouseout: (e) => geojsonLayer.resetStyle(e.target)
                });
            }
        }

        // --- Function to Initialize Map (without data) ---
        function initializeMap() {
            try {
                mapInstance = L.map('map', {
                    scrollWheelZoom: false
                }).setView([11.1, 122.5], 8);
                
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                }).addTo(mapInstance);

                mapInstance.on('click', () => mapInstance.scrollWheelZoom.enable());
                mapInstance.on('mouseout', () => mapInstance.scrollWheelZoom.disable());

                mapLegend = L.control({position: 'bottomright'});
                mapLegend.onAdd = function (map) {
                    const div = L.DomUtil.create('div', 'info legend');
                    updateMapLegend(div); // Call helper to populate legend
                    return div;
                };
                mapLegend.addTo(mapInstance);

            } catch (error) {
                 console.error('Error initializing map:', error);
                 document.getElementById('map').innerHTML = `<div class="p-4 text-center text-red-500">Error initializing map: ${error.message}</div>`;
            }
        }

        // --- <<< ADDED: Helper to update map legend text and colors >>> ---
        function updateMapLegend(div) {
            const selectedMetric = metricSelector.value;
            const selectedMetricText = metricSelector.options[metricSelector.selectedIndex].text;
            
            let thresholds = [0, 100000, 1000000, 5000000, 10000000, 20000000, 50000000, 100000000]; // Default for money
            let formatFunc = formatNumber; // Default for money/PHP

            if (selectedMetric.includes('farmers')) {
                thresholds = [0, 100, 500, 1000, 2500, 5000, 10000, 20000];
                formatFunc = formatInt;
            } else if (selectedMetric.includes('area')) {
                 thresholds = [0, 100, 500, 1000, 2500, 5000, 10000, 20000];
                 formatFunc = (val) => formatInt(val) + ' ha'; // Add 'ha' suffix
            }

            if (div) { // Only update if div exists
                div.innerHTML = `<strong>${selectedMetricText}</strong><br>`;
                for (let i = 0; i < thresholds.length; i++) {
                    const from = thresholds[i];
                    const to = thresholds[i + 1];
                    const color = getMapColor(from + 1); // Get color for this grade
                    
                    div.innerHTML +=
                        '<i style="background:' + color + '"></i> ' +
                        formatFunc(from) + (to ? '&ndash;' + formatFunc(to) + '<br>' : '+');
                }
            }
        }

        // --- Function to toggle map size ---
        function toggleMapSize() {
            const isSmall = mapContainer.classList.contains('map-container-small');
            if (isSmall) {
                mapContainer.classList.remove('map-container-small');
                mapContainer.classList.add('map-container-large');
                mapExpandIcon.classList.add('hidden');
                mapMinimizeIcon.classList.remove('hidden');
            } else {
                mapContainer.classList.remove('map-container-large');
                mapContainer.classList.add('map-container-small');
                mapExpandIcon.classList.remove('hidden');
                mapMinimizeIcon.classList.add('hidden');
            }
            setTimeout(() => {
                if (mapInstance) {
                    mapInstance.invalidateSize();
                }
            }, 300);
        }
        toggleMapBtn.addEventListener('click', toggleMapSize);


        // --- Function to Update Map with Filtered Data ---
        async function updateMap(params) {
            console.log("Updating map data...");
            // <<< ADDED: Update map legend and title based on metric selector >>>
            const selectedMetricText = metricSelector.options[metricSelector.selectedIndex].text;
            mapTitleMetric.textContent = selectedMetricText;
            if (mapLegend && mapLegend.getContainer()) {
                updateMapLegend(mapLegend.getContainer());
            }

            try {
                const filteredMapUrl = `${mapApiUrl}?${params.toString()}`;
                console.log("Fetching map data from:", filteredMapUrl);
                
                const response = await fetch(filteredMapUrl);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const geojsonData = await response.json();
                console.log("Filtered map data fetched:", geojsonData.features.length, "features");

                if (geojsonLayer) {
                    mapInstance.removeLayer(geojsonLayer);
                }
                
                if (geojsonData.features.length > 0) {
                    geojsonLayer = L.geoJSON(geojsonData, {
                        style: styleMapFeature, // Style is now dynamic based on metric
                        onEachFeature: onEachMapFeature // Popup is now dynamic based on metric
                    }).addTo(mapInstance);
                    
                    mapInstance.fitBounds(geojsonLayer.getBounds());
                } else {
                    mapInstance.setView([11.1, 122.5], 8);
                }

            } catch (error) {
                 console.error('Error fetching data for map:', error);
                 errorDiv.textContent = `Error loading map data: ${error.message}`;
                 errorDiv.classList.remove('hidden');
            }
        }


        // --- Fetch and Populate Filter Dropdowns ---
        async function populateFilters() {
            console.log("Populating filters...");
            try {
                const response = await fetch(`${chartApiUrl}?limit=5000`);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const result = await response.json();
                if (result.status === 'success' && result.data) {
                    const allData = result.data;
                    
                    const provincesSet = new Set();
                    const categoriesSet = new Set();
                    const yearsSet = new Set();
                    const commoditiesSet = new Set(); // <<< ADDED
                    provinceMunicipalityMap = {};

                    allData.forEach(item => {
                        const province = item.province;
                        const municipality = item.municipality;
                        const category = item.disaster_category;
                        const commodity = item.commodity; // <<< ADDED

                        if (province && province !== 'Unknown') {
                            provincesSet.add(province);
                            
                            if (municipality && municipality !== 'Unknown') {
                                if (!provinceMunicipalityMap[province]) {
                                    provinceMunicipalityMap[province] = new Set();
                                }
                                provinceMunicipalityMap[province].add(municipality);
                            }
                        }
                        if (category && category !== 'Unknown') {
                            categoriesSet.add(category);
                        }
                        if (commodity && commodity !== 'Unknown') { // <<< ADDED
                            commoditiesSet.add(commodity);
                        }
                        if (item.year && item.year > 1900) {
                            yearsSet.add(item.year);
                        }
                    });

                    const provinces = [...provincesSet].sort();
                    const categories = [...categoriesSet].sort();
                    const years = [...yearsSet].sort((a, b) => b - a);
                    const commodities = [...commoditiesSet].sort(); // <<< ADDED
                    for (const prov in provinceMunicipalityMap) {
                        provinceMunicipalityMap[prov] = [...provinceMunicipalityMap[prov]].sort();
                    }

                    while (provinceFilter.options.length > 1) provinceFilter.remove(1);
                    while (categoryFilter.options.length > 1) categoryFilter.remove(1);
                    while (yearFilter.options.length > 1) yearFilter.remove(1);
                    while (commodityFilter.options.length > 1) commodityFilter.remove(1); // <<< ADDED

                    provinces.forEach(p => provinceFilter.add(new Option(p, p)));
                    categories.forEach(c => categoryFilter.add(new Option(c, c)));
                    years.forEach(y => yearFilter.add(new Option(y, y)));
                    commodities.forEach(c => commodityFilter.add(new Option(c, c))); // <<< ADDED
                    console.log("Filters populated.");
                } else {
                     console.error("Could not fetch data to populate filters:", result.message || "Unknown error");
                }
            } catch (error) {
                 console.error('Error fetching data for filters:', error);
                 errorDiv.textContent = `Error populating filters: ${error.message}. Check API server.`;
                 errorDiv.classList.remove('hidden');
            }
        }

        // --- Function to Update Municipality Filter ---
        function updateMunicipalityFilter() {
            const selectedProvince = provinceFilter.value;
            while (municipalityFilter.options.length > 1) municipalityFilter.remove(1);
            
            if (selectedProvince && provinceMunicipalityMap[selectedProvince]) {
                municipalityFilter.disabled = false;
                municipalityFilter.classList.remove('bg-gray-200');
                municipalityFilter.options[0].text = "All Municipalities";
                
                provinceMunicipalityMap[selectedProvince].forEach(mun => {
                    municipalityFilter.add(new Option(mun, mun));
                });
            } else {
                municipalityFilter.disabled = true;
                municipalityFilter.classList.add('bg-gray-200');
                municipalityFilter.options[0].text = "All (Select Province First)";
            }
        }
        provinceFilter.addEventListener('change', updateMunicipalityFilter);

        // --- Function to handle mutually exclusive time filters ---
        function handleTimeFilterChange(source) {
            const quarter = quarterFilter.value;
            const year = yearFilter.value;
            const start = startDateFilter.value;
            const end = endDateFilter.value;

            if (source === 'quarterYear') {
                if (quarter || year) {
                    startDateFilter.value = '';
                    endDateFilter.value = '';
                    startDateFilter.disabled = true;
                    endDateFilter.disabled = true;
                } else {
                    startDateFilter.disabled = false;
                    endDateFilter.disabled = false;
                }
            } else if (source === 'dateRange') {
                if (start || end) {
                    quarterFilter.value = '';
                    yearFilter.value = '';
                    quarterFilter.disabled = true;
                    yearFilter.disabled = true;
                } else {
                    quarterFilter.disabled = false;
                    yearFilter.disabled = false;
                }
            }
        }
        quarterFilter.addEventListener('change', () => handleTimeFilterChange('quarterYear'));
        yearFilter.addEventListener('change', () => handleTimeFilterChange('quarterYear'));
        startDateFilter.addEventListener('input', () => handleTimeFilterChange('dateRange'));
        endDateFilter.addEventListener('input', () => handleTimeFilterChange('dateRange'));


        // --- Main function to fetch all data ---
        async function fetchDataAndDisplay() {
            loadingDiv.style.display = 'block';
            errorDiv.classList.add('hidden');
            noDataDiv.classList.add('hidden');
            dataTable.classList.add('hidden');
            dataTableBody.innerHTML = '';
            tableNote.classList.add('hidden');
            tableSearchInput.value = '';

            if (barChartInstance) barChartInstance.destroy();
            if (timeSeriesChartInstance) timeSeriesChartInstance.destroy();
            if (categoryPieChartInstance) categoryPieChartInstance.destroy();

            const params = new URLSearchParams();
            const province = provinceFilter.value;
            const category = categoryFilter.value;
            const municipality = municipalityFilter.value;
            const commodity = commodityFilter.value; // <<< ADDED
            const quarter = quarterFilter.value;
            const year = yearFilter.value;
            const startDate = startDateFilter.value;
            const endDate = endDateFilter.value;

            if (province) params.append('province', province);
            if (category) params.append('disaster_category', category);
            if (municipality) params.append('municipality', municipality);
            if (commodity) params.append('commodity', commodity); // <<< ADDED
            if (quarter) params.append('quarter', quarter);
            if (year) params.append('year', year);
            if (startDate) params.append('start_date', startDate);
            if (endDate) params.append('end_date', endDate);
            
            // --- Fetch Map Data and Chart Data in Parallel ---
            const mapParams = new URLSearchParams(params);
            updateMap(mapParams); 

            const chartParams = new URLSearchParams(params);
            chartParams.append('limit', 5000);
            fetchChartData(chartParams);
        }

        // --- Function dedicated to fetching chart/table data ---
        async function fetchChartData(params) {
            const filteredChartUrl = `${chartApiUrl}?${params.toString()}`;
            console.log("Fetching chart data from:", filteredChartUrl);

            // <<< ADDED: Get selected metric for chart processing >>>
            const selectedMetric = metricSelector.value;
            const selectedMetricText = metricSelector.options[metricSelector.selectedIndex].text;
            // Update small chart titles
            timeSeriesTitleMetric.textContent = selectedMetricText.split(' (')[0]; // "Total Losses" -> "Total Losses"
            pieTitleMetric.textContent = selectedMetricText.split(' (')[0];

            try {
                const response = await fetch(filteredChartUrl);
                if (!response.ok) {
                    let errorMsg = `HTTP error! status: ${response.status}`;
                    try { const errorData = await response.json(); if (errorData && errorData.message) errorMsg += ` - ${errorData.message}`; } catch (e) {}
                    throw new Error(errorMsg);
                }
                const result = await response.json();

                if (result.status === 'success' && result.data && result.data.length > 0) {
                    const data = result.data;
                    console.log(`Filtered chart data fetched: ${data.length} items`, data.slice(0, 5));

                    // --- 1. Prepare Data for Bar Chart ---
                    let barGroupByKey = 'province';
                    let barChartTitle = `Total ${selectedMetricText} by Province`;
                    const province = params.get('province');
                    const municipality = params.get('municipality');
                    const category = params.get('disaster_category');

                    if (province && !municipality) { barGroupByKey = 'municipality'; barChartTitle = `Total ${selectedMetricText} by Municipality in ${province}`; }
                    else if (province && municipality) { barGroupByKey = 'disaster_category'; barChartTitle = `Total ${selectedMetricText} by Category in ${municipality}`; }
                    else if (!province && category) { barGroupByKey = 'province'; barChartTitle = `Total ${selectedMetricText} from ${category} by Province`; }
                    else if (province && category) { barGroupByKey = 'municipality'; barChartTitle = `Total ${selectedMetricText} from ${category} in ${province}`; }


                    const lossesByBarGroup = data.reduce((acc, item) => {
                        const key = item[barGroupByKey] || 'Unknown';
                        // <<< MODIFIED: Use selectedMetric for value >>>
                        const metricValue = parseFloat(item[selectedMetric]);
                        acc[key] = (acc[key] || 0) + (isNaN(metricValue) ? 0 : metricValue);
                        return acc;
                    }, {});

                    const sortedBarGroups = Object.entries(lossesByBarGroup).sort(([,a],[,b]) => b-a);
                    const barLabels = sortedBarGroups.map(([key]) => key);
                    const barValues = sortedBarGroups.map(([,value]) => value);


                    // --- 2. Prepare Data for Line Chart (Monthly) ---
                    const lossesByMonth = data.reduce((acc, item) => {
                        if (item.event_date_start && item.event_date_start !== null && item.event_date_start !== 'N/A') {
                            const monthYear = dayjs(item.event_date_start).isValid() ? dayjs(item.event_date_start).format('YYYY-MM') : null;
                             if (monthYear) {
                                // <<< MODIFIED: Use selectedMetric for value >>>
                                const metricValue = parseFloat(item[selectedMetric]);
                                acc[monthYear] = (acc[monthYear] || 0) + (isNaN(metricValue) ? 0 : metricValue);
                            }
                        }
                        return acc;
                    }, {});
                    const sortedMonths = Object.keys(lossesByMonth).sort();
                    const monthlyLossValues = sortedMonths.map(month => lossesByMonth[month]);

                    // --- 3. Prepare Data for Pie Chart (Category Distribution) ---
                    const lossesByCategory = data.reduce((acc, item) => {
                        const key = item.disaster_category || 'Unknown';
                        // <<< MODIFIED: Use selectedMetric for value >>>
                        const metricValue = parseFloat(item[selectedMetric]);
                        acc[key] = (acc[key] || 0) + (isNaN(metricValue) ? 0 : metricValue);
                        return acc;
                    }, {});
                    
                    const sortedCategories = Object.entries(lossesByCategory).sort(([,a],[,b]) => b-a);
                    const topN = 8;
                    let categoryLabels = [];
                    let categoryLossValues = [];
                    let otherLosses = 0;

                    sortedCategories.forEach(([key, value], index) => {
                        if (value > 0) {
                            if (index < topN) {
                                categoryLabels.push(key);
                                categoryLossValues.push(value);
                            } else {
                                otherLosses += value;
                            }
                        }
                    });

                    if (otherLosses > 0) {
                        categoryLabels.push('OTHERS');
                        categoryLossValues.push(otherLosses);
                    }

                    // --- Create Bar Chart ---
                    // Dynamic formatter for tooltips/axes
                    const isCurrency = selectedMetric.includes('losses');
                    const metricFormatFunc = isCurrency ? formatCurrency : formatInt;
                    const metricAxisLabel = isCurrency ? "Value (PHP)" : "Count";

                    const barCtx = barChartCanvas.getContext('2d');
                    barChartInstance = new Chart(barCtx, {
                        type: 'bar',
                        data: {
                            labels: barLabels,
                            datasets: [{
                                label: selectedMetricText,
                                data: barValues,
                                backgroundColor: 'rgba(54, 162, 235, 0.6)',
                                borderColor: 'rgba(54, 162, 235, 1)',
                                borderWidth: 1
                             }]
                        },
                        options: {
                            responsive: true, maintainAspectRatio: false, indexAxis: 'y',
                             scales: {
                                 y: { 
                                     beginAtZero: true,
                                     title: { display: true, text: barGroupByKey.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase()) }
                                 },
                                 x: { 
                                      title: { display: true, text: selectedMetricText },
                                      ticks: { callback: formatNumber } // Use generic formatNumber for axis
                                 }
                            },
                            plugins: {
                                legend: { display: false },
                                title: { display: true, text: barChartTitle, font: { size: 16 } },
                                tooltip: { callbacks: { label: ctx => `${selectedMetricText}: ${metricFormatFunc(ctx.parsed.x)}` } }
                            }
                        }
                    });

                    // --- Create Line Chart ---
                    if (sortedMonths.length > 0) {
                        const lineCtx = timeSeriesCanvas.getContext('2d');
                        timeSeriesChartInstance = new Chart(lineCtx, {
                             type: 'line',
                             data: { labels: sortedMonths, datasets: [{ label: `Monthly ${selectedMetricText}`, data: monthlyLossValues, borderColor: 'rgb(75, 192, 192)', backgroundColor: 'rgba(75, 192, 192, 0.2)', tension: 0.1, fill: true }] },
                             options: { 
                                 responsive: true, 
                                 maintainAspectRatio: false, 
                                 scales: { 
                                     y: { beginAtZero: true, title: { display: true, text: selectedMetricText }, ticks: { callback: formatNumber } }, 
                                     x: { title: { display: true, text: 'Month' } } 
                                 }, 
                                 plugins: { 
                                     legend: { display: false }, 
                                     title: { display: false }, 
                                     tooltip: { callbacks: { label: ctx => `Total: ${metricFormatFunc(ctx.parsed.y)}` } } 
                                 } 
                             }
                        });
                    } else {
                         const lineCtx = timeSeriesCanvas.getContext('2d');
                         lineCtx.clearRect(0, 0, timeSeriesCanvas.width, timeSeriesCanvas.height);
                         lineCtx.font = '16px "Inter"';
                         lineCtx.fillStyle = '#6b7280';
                         lineCtx.textAlign = 'center';
                         lineCtx.fillText('No monthly data to display.', timeSeriesCanvas.width / 2, timeSeriesCanvas.height / 2);
                    }


                    // --- Create Pie Chart ---
                     if (categoryLabels.length > 0) {
                        const pieCtx = categoryPieCanvas.getContext('2d');
                        const pieColors = ['rgba(255, 99, 132, 0.7)', 'rgba(54, 162, 235, 0.7)', 'rgba(255, 206, 86, 0.7)', 'rgba(75, 192, 192, 0.7)', 'rgba(153, 102, 255, 0.7)', 'rgba(255, 159, 64, 0.7)', 'rgba(199, 199, 199, 0.7)', 'rgba(83, 102, 255, 0.7)', 'rgba(100, 255, 100, 0.7)'];
                        categoryPieChartInstance = new Chart(pieCtx, {
                             type: 'pie',
                             data: { labels: categoryLabels, datasets: [{ label: selectedMetricText, data: categoryLossValues, backgroundColor: pieColors.slice(0, categoryLabels.length), hoverOffset: 4 }] },
                             options: { 
                                 responsive: true, 
                                 maintainAspectRatio: false, 
                                 plugins: { 
                                     legend: { 
                                         position: 'right',
                                         labels: { padding: 10, boxWidth: 12 }
                                     }, 
                                     title: { display: false }, 
                                     tooltip: { callbacks: { label: ctx => `${ctx.label}: ${metricFormatFunc(ctx.parsed)}` } } 
                                 } 
                             }
                        });
                    } else {
                         const pieCtx = categoryPieCanvas.getContext('2d');
                         pieCtx.clearRect(0, 0, categoryPieCanvas.width, categoryPieCanvas.height);
                         pieCtx.font = '16px "Inter"';
                         pieCtx.fillStyle = '#6b7280';
                         pieCtx.textAlign = 'center';
                         pieCtx.fillText('No category data to display.', categoryPieCanvas.width / 2, categoryPieCanvas.height / 2);
                    }


                    // --- Populate Table (Limited Rows) ---
                    const tableLimit = 100;
                    let farmerDataAvailable = false;
                    data.slice(0, tableLimit).forEach(item => {
                        const row = document.createElement('tr');
                        row.className = 'hover:bg-gray-50 text-sm';

                        const hasFarmerData = item.registered_rice_farmers !== null && item.registered_rice_farmers !== undefined && item.registered_rice_farmers > 0;
                        if (hasFarmerData) farmerDataAvailable = true;

                        // <<< MODIFIED: Expanded table data >>>
                        row.innerHTML = `
                            <td class="px-4 py-2 whitespace-nowrap text-gray-700">${formatText(item.event_date_start)}</td>
                            <td class="px-4 py-2 whitespace-nowrap text-gray-700">${formatText(item.province)}</td>
                            <td class="px-4 py-2 whitespace-nowrap text-gray-700">${formatText(item.municipality)}</td>
                            <td class="px-4 py-2 whitespace-nowrap text-gray-700">${formatText(item.commodity)}</td>
                            <td class="px-4 py-2 whitespace-nowrap text-gray-700">${formatText(item.disaster_category)}</td>
                            <td class="px-4 py-2 whitespace-nowrap text-gray-700 text-right">${formatInt(item.farmers_affected)}</td>
                            <td class="px-4 py-2 whitespace-nowrap text-gray-700 text-right">${formatRegistryNumber(item.area_total_affected_ha)}</td>
                            <td class="px-4 py-2 whitespace-nowrap text-gray-700 text-right">${formatRegistryNumber(item.area_partially_damaged_ha)}</td>
                            <td class="px-4 py-2 whitespace-nowrap text-gray-700 text-right">${formatRegistryNumber(item.area_totally_damaged_ha)}</td>
                            <td class="px-4 py-2 whitespace-nowrap text-gray-700 text-right">${formatCurrency(item.losses_php_production_cost)}</td>
                            <td class="px-4 py-2 whitespace-nowrap text-gray-700 text-right">${formatCurrency(item.losses_php_farm_gate)}</td>
                            <td class="px-4 py-2 whitespace-nowrap text-gray-700 text-right">${formatCurrency(item.losses_php_grand_total)}</td>
                            <td class="px-4 py-2 whitespace-nowrap text-gray-700 text-right">${formatRegistryNumber(item.registered_rice_farmers)}</td>
                            <td class="px-4 py-2 whitespace-nowrap text-gray-700 text-right">${formatRegistryNumber(item.total_declared_rice_area_ha)}</td>
                            <td class="px-4 py-2 whitespace-nowrap text-gray-700 text-right">${formatPercentage(item.percentage_farmers_affected)}</td>
                        `;
                        dataTableBody.appendChild(row);
                     });
                     dataTable.classList.remove('hidden');
                     if (farmerDataAvailable) {
                         tableNote.classList.remove('hidden');
                     }


                    loadingDiv.style.display = 'none';

                } else if (result.status === 'success' && (!result.data || result.data.length === 0)) {
                    loadingDiv.style.display = 'none';
                    noDataDiv.classList.remove('hidden');
                    console.log("API returned success but no data for selected filters.");
                }
                 else {
                     throw new Error(result.message || 'API returned success status but no valid data.');
                }
            } catch (error) {
                console.error('Error fetching or processing chart data:', error);
                loadingDiv.style.display = 'none';
                errorDiv.textContent = `Error loading chart/table data: ${error.message}. Is the API server running and responding correctly?`;
                errorDiv.classList.remove('hidden');
            }
        }

        // --- Event Listener for Filter Button ---
        applyFiltersBtn.addEventListener('click', fetchDataAndDisplay);

        // --- Event Listener and Function for Table Search ---
        function filterTable() {
            const searchTerm = tableSearchInput.value.toLowerCase();
            const rows = dataTableBody.getElementsByTagName('tr');

            for (let i = 0; i < rows.length; i++) {
                const row = rows[i];
                const rowText = row.textContent || row.innerText;

                if (rowText.toLowerCase().indexOf(searchTerm) > -1) {
                    row.style.display = ""; // Show row
                } else {
                    row.style.display = "none"; // Hide row
                }
            }
        }
        tableSearchInput.addEventListener('keyup', filterTable);


        // --- Initial Load ---
        async function initializeDashboard() {
            initializeMap();
            await populateFilters();
            await fetchDataAndDisplay();
        }

        initializeDashboard();

    </script>

</body>
</html>

